# Compilation

g++ -Wall -ansi -pedantic -fPIC -std=c++11 relax.cc -o relax

g++ -Wall -ansi -pedantic -fPIC -std=c++11 relax.cc -o relax -fopenmp -lpthread -D OPENMP

pgcc -acc -Minfo=accel -std=c++11 relax.cc -o relax -D OACC
#
# CPU single thread, n=200, epsilon = 1e-6, maxiter = 100k
#

9900, 0.0000011921
10000, 0.0000011921
10100, 0.0000010729

Iteration Complete. Total Iterations: 10171, Time Elapsed: 6.995987 (s)
Writing to "output.csv" ...

#
# OpenMP 12 thread, n=200, epsilon = 1e-6, maxiter = 100k
#

9900, 0.0000011921
10000, 0.0000011921
10100, 0.0000010729

Iteration Complete. Total Iterations: 10165, Time Elapsed: 75.941437 (s)
Writing to "output.csv" ...

#
# CPU single thread, n=500, epsilon = 1e-6, maxiter = 100k
#

45300, 0.0000010729
45400, 0.0000010729
45500, 0.0000010729

Iteration Complete. Total Iterations: 45568, Time Elapsed: 207.131790 (s)
Writing to "output.csv" ...

#
# OpenMP 12 thread, n=500, epsilon = 1e-6, maxiter = 100k
#

45300, 0.0000010729
45400, 0.0000010729
45500, 0.0000010133

Iteration Complete. Total Iterations: 45564, Time Elapsed: 1749.814941 (s)
Writing to "output.csv" ...

#
# There's a problem here.
#

It has to do with the way the error is being calculated. It does not make any sense for there to be a single error field in a multithreaded approach.

Ideas: error matrix, have one thread go through it and find the max O(N^2)

Can alleviate some computation expense by checking once every T iterations,

where T is the # of threads. It's O(N^2) and so is the calculation, so we need two threads available for this to just be a wash.


# 2015-10-24

# added an error matrix and I do an "error check" only every certain # of batches.

#
# CPU single thread, n=200, epsilon = 1e-6, maxiter = 100k, b=100
#

10000, 0.0000011921
10100, 0.0000010729
10200, 0.0000009537

Iteration Complete. Total Iterations: 10200, Time Elapsed: 6.462040 (s)
Writing to "output.csv" ...

#
# OpenMP 12 thread, n=200, epsilon = 1e-6, maxiter = 100k, c=100
#

10000, 0.0000011921
10100, 0.0000010729
10200, 0.0000009537

Iteration Complete. Total Iterations: 10200, Time Elapsed: 31.055468 (s)
Writing to "output.csv" ...

# this is an improvement of a factor of two from the initial attempts

#
# OpenMP 12 thread, n=500, epsilon = 1e-6, maxiter = 100k, c=100
#

45400, 0.0000010729
45500, 0.0000010729
45600, 0.0000009537

Iteration Complete. Total Iterations: 45600, Time Elapsed: 753.104797 (s)
Writing to "output.csv" ...


# hmm, still only a factor of two (ish), and still doesn't beat single thread time

#
# OpenMP 10 thread, n=500, epsilon = 1e-6, maxiter = 100k, c=100
# num_threads(10)

45400, 0.0000010729
45500, 0.0000010729
45600, 0.0000009537

Iteration Complete. Total Iterations: 45600, Time Elapsed: 633.672302 (s)
Writing to "output.csv" ...

# how is this better?!?!?!?!? lets see what happens with 8 and 6 threads.

#
# OpenMP 8 thread, n=500, epsilon = 1e-6, maxiter = 100k, c=100
# num_threads(8)

45400, 0.0000010729
45500, 0.0000010729
45600, 0.0000009537

Iteration Complete. Total Iterations: 45600, Time Elapsed: 581.596863 (s)
Writing to "output.csv" ...

# lmao what in the fuck...

#
# OpenMP 6 thread, n=500, epsilon = 1e-6, maxiter = 100k, c=100
# num_threads(6)

45400, 0.0000010729
45500, 0.0000010729
45600, 0.0000009537

Iteration Complete. Total Iterations: 45600, Time Elapsed: 350.843628 (s)
Writing to "output.csv" ...

# something is seriously fucked. It's clear that less threads = more performance
# which doesn't make any sense because I am not writing to the same index in
# any thread.

# Ahhhhhh, something weird is happening. Time elapsed reporting as way too long
# see reductionmax.png. That only took ~60s real time. But reporting as 720s.
# GUESS WHAT 60 * 12 IS. BASICALLY, I NEED TO NOT BE RETARDED AND PROPERLY
# DEFINE THE REGIONS OF CODE THAT OPENMP NEEDS TO LOOK AT.
# HINT: NOT MY FUCKING TIMER. I need to redo all this crap from the beginning.
# (oh well)
